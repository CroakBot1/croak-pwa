<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>üì° 50 Pairs 1m ‚Äî 50,000 Historical + Live WebSocket + Indicators + Buy Alerts</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#000; --card:#0b0b0b; --grid:#141414; --txt:#c8facc; --muted:#98f598; --accent:#00ffff; --bad:#ff4d4d; --good:#00ff84; --border:#1aff1a;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--txt);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;padding:14px;display:grid;gap:14px;grid-template-columns: 1.4fr 1fr}
    h2{grid-column:1/-1;margin:0 0 6px}
    .bar{grid-column:1/-1;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .pill{padding:6px 10px;border:1px solid var(--border);border-radius:999px;background:var(--card)}
    .tiny{font-size:12px;opacity:.9}
    button{background:#000;color:var(--txt);border:1px solid var(--border);padding:6px 10px;border-radius:8px;cursor:pointer}
    button:hover{filter:brightness(1.15)}
    #chartWrap{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:8px;position:relative;min-height:420px}
    #chart{width:100%;height:420px;display:block;background:#000}
    #output,#panel{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px;max-height:460px;overflow:auto;white-space:pre-wrap;word-break:break-word}
    #panel h3{color:var(--accent);margin:10px 0 6px}
    .row{display:flex;gap:10px;align-items:center}
    .green{color:var(--good)} .red{color:var(--bad)} .muted{color:var(--muted)}
    .grid{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:8px;display:grid;grid-template-columns:repeat(auto-fill,minmax(130px,1fr));gap:8px;max-height:460px;overflow:auto}
    .tile{border:1px solid #0f0;border-radius:10px;padding:6px;background:#020202;cursor:pointer}
    .tile h4{margin:0 0 4px;font-size:12px;color:#9ff59f}
    .spark{width:100%;height:36px;background:#000;border-radius:6px}
    .badg{display:inline-block;padding:2px 6px;border:1px solid var(--border);border-radius:999px;margin-top:4px;font-size:11px}
    .buy{background:#001a00;color:#00ff84}
    .warn{background:#1a0000;color:#ff4d4d;border-color:#ff4d4d}
    select{background:#000;color:var(--txt);border:1px solid var(--border);border-radius:8px;padding:6px}
  </style>
</head>
<body>
  <h2>üì° 50 Pairs 1m ‚Äî 10,000 Historical + Live + Buy Alerts</h2>
  <div class="bar">
    <div class="pill" id="status">Status: starting‚Ä¶</div>
    <div class="pill" id="progress">Fetched: 0 / 500,000</div>
    <div class="pill" id="live">Live: disconnected</div>
    <div class="pill">Visible: <span id="visN">300</span> bars</div>
    <div class="pill tiny">Tip: Mobile may struggle keeping 50 sockets; this app uses a <b>combined WebSocket</b> stream.</div>
    <label class="pill">Active: <select id="symbolSel"></select></label>
    <button id="btnPause">‚è∏Ô∏è Pause Live</button>
    <button id="btnResume">‚ñ∂Ô∏è Resume Live</button>
    <button id="btnJumpNow">‚§¥ Jump to Now</button>
  </div>

  <div id="chartWrap">
    <canvas id="chart"></canvas>
  </div>

  <pre id="output">Starting‚Ä¶</pre>
  <div id="panel">Loading indicators‚Ä¶</div>

  <div class="grid" id="tiles"></div>

<script>
/** ==============================
 *  CONFIG
 *  ============================== */
const SYMBOLS = [
  'BTCUSDT','ETHUSDT','BNBUSDT','SOLUSDT','XRPUSDT','ADAUSDT','DOGEUSDT','TRXUSDT','MATICUSDT','DOTUSDT',
  'LTCUSDT','BCHUSDT','LINKUSDT','ATOMUSDT','AVAXUSDT','XLMUSDT','ETCUSDT','FILUSDT','ICPUSDT','NEARUSDT',
  'APTUSDT','ARBUSDT','OPUSDT','SUIUSDT','SEIUSDT','PEPEUSDT','SHIBUSDT','FTMUSDT','ALGOUSDT','AAVEUSDT',
  'UNIUSDT','TONUSDT','MKRUSDT','INJUSDT','IMXUSDT','RUNEUSDT','SNXUSDT','GMXUSDT','DYDXUSDT','EGLDUSDT',
  'EOSUSDT','STXUSDT','GRTUSDT','SANDUSDT','MANAUSDT','AXSUSDT','CHZUSDT','ENJUSDT','CFXUSDT','QTUMUSDT'
];
const INTERVAL = '1m';
const REST_LIMIT = 1000; // Binance max per request
const PRELOAD = 50_000;  // per pair
const STORE_ALL = false; // cap memory to last 12k for safety
const MAX_STORE = 12_000;
const VISIBLE = 300;
const FETCH_DELAY_MS = 30; // gentle throttle between batches per pair
const DRAW_EVERY = 200;    // redraw cadence during preload

/** ==============================
 *  STATE & UI
 *  ============================== */
const output = document.getElementById('output');
const panel  = document.getElementById('panel');
const statusEl = document.getElementById('status');
const progressEl = document.getElementById('progress');
const liveEl = document.getElementById('live');
const visNEl = document.getElementById('visN');
const btnPause = document.getElementById('btnPause');
const btnResume = document.getElementById('btnResume');
const btnJumpNow = document.getElementById('btnJumpNow');
const tiles = document.getElementById('tiles');
const symbolSel = document.getElementById('symbolSel');

let active = SYMBOLS[0];
let livePaused = false;
let fetchedTotal = 0;
let ws = null;

const per = {}; // per[symbol] = { candles:[], lastAlertTs:null, lastUpdateTs:0 }

SYMBOLS.forEach(s=>{
  per[s] = { candles:[], lastAlertTs:0, lastWsCandleTs:0 };
  const opt = document.createElement('option'); opt.value = s; opt.textContent = s; symbolSel.appendChild(opt);
});
symbolSel.value = active;
symbolSel.onchange = ()=>{ active = symbolSel.value; drawChart(true); updateIndicators(active); };

/** ==============================
 *  UTILS
 *  ============================== */
const sleep = (ms) => new Promise(r => setTimeout(r, ms));
const fmt = (n, d=2) => (n == null || Number.isNaN(n)) ? '‚è≥' : Number(n).toFixed(d);
const pushLog = (s) => { output.textContent = s + "\n" + output.textContent; };
const clampStore = (arr) => { if (!STORE_ALL && arr.length > MAX_STORE) return arr.slice(-MAX_STORE); return arr; };

/** ==============================
 *  Notifications (native pop-up)
 *  ============================== */
async function ensureNotify(){
  try{ if (Notification && Notification.permission === 'default') await Notification.requestPermission(); }catch{}
}
function notify(title, body){
  try{
    if (Notification && Notification.permission === 'granted') new Notification(title,{ body });
  }catch{}
  // Also show a JS alert() for guaranteed pop if user is active
  try{ alert(`${title}\n${body}`); }catch{}
}

/** ==============================
 *  REST: Preload 10,000 candles per pair (backwards)
 *  ============================== */
async function fetchHistoryFor(sym){
  const target = PRELOAD; let fetched = 0; let endTime = Date.now();
  const st = per[sym];
  while (fetched < target){
    const url = new URL('https://api.binance.com/api/v3/klines');
    url.searchParams.set('symbol', sym);
    url.searchParams.set('interval', INTERVAL);
    url.searchParams.set('endTime', endTime);
    url.searchParams.set('limit', REST_LIMIT);
    try{
      const res = await fetch(url.toString());
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      const raw = await res.json();
      if(!Array.isArray(raw) || raw.length === 0){ pushLog(`‚ö†Ô∏è ${sym}: no more history`); break; }
      const batch = raw.map(k=>({ time:k[0], open:+k[1], high:+k[2], low:+k[3], close:+k[4], volume:+k[5] }));
      st.candles = batch.concat(st.candles);
      fetched += batch.length; fetchedTotal += batch.length;
      endTime = batch[0].time - 1;
      st.candles = clampStore(st.candles);
      if (fetched % DRAW_EVERY === 0 && sym === active) drawChart();
      progressEl.textContent = `Fetched: ${fetchedTotal.toLocaleString()} / ${(SYMBOLS.length*PRELOAD).toLocaleString()}`;
      await sleep(FETCH_DELAY_MS);
      if (raw.length < REST_LIMIT) break;
    }catch(e){ pushLog(`‚ùå ${sym} fetch error: ${e.message}`); await sleep(500); }
  }
}

async function preloadAll(){
  statusEl.textContent = 'Status: preloading 10k per pair‚Ä¶';
  // Render tiles
  tiles.innerHTML = '';
  SYMBOLS.forEach(s=>{
    const div = document.createElement('div'); div.className='tile'; div.onclick=()=>{ active=s; symbolSel.value=s; drawChart(true); updateIndicators(s); };
    div.innerHTML = `<h4>${s}</h4><canvas class="spark" id="sp_${s}"></canvas><div class="badg" id="bd_${s}">‚Äî</div>`;
    tiles.appendChild(div);
  });
  // Parallel with small staggering to avoid burst
  for (let i=0;i<SYMBOLS.length;i++){
    const s = SYMBOLS[i];
    fetchHistoryFor(s).then(()=>{
      if (s===active){ updateIndicators(s); drawChart(true); }
      drawSpark(s);
    });
    await sleep(80);
  }
  statusEl.textContent = 'Status: preload started (streams will attach)';
}

/** ==============================
 *  WebSocket: Combined stream for all pairs
 *  ============================== */
function startCombinedWS(){
  if (ws) try{ ws.close(); }catch{}
  const streams = SYMBOLS.map(s => `${s.toLowerCase()}@kline_${INTERVAL}`).join('/');
  const url = `wss://stream.binance.com:9443/stream?streams=${streams}`;
  ws = new WebSocket(url);

  ws.onopen = ()=>{ liveEl.textContent = 'Live: connected'; pushLog('‚úÖ Combined WebSocket connected.'); };
  ws.onerror = ()=>{ liveEl.textContent = 'Live: error'; pushLog('‚ùå WebSocket error'); };
  ws.onclose = ()=>{ liveEl.textContent = 'Live: closed'; pushLog('‚ö†Ô∏è WebSocket closed. Reconnecting‚Ä¶'); setTimeout(startCombinedWS, 1500); };

  ws.onmessage = (ev)=>{
    if (livePaused) return;
    const msg = JSON.parse(ev.data);
    if (!msg || !msg.data || !msg.data.k) return;
    const k = msg.data.k; const sym = msg.data.s || k.s || msg.stream?.split('@')[0].toUpperCase();
    const st = per[sym]; if(!st) return;

    const incoming = { time:k.t, open:+k.o, high:+k.h, low:+k.l, close:+k.c, volume:+k.v };
    const arr = st.candles;
    const last = arr[arr.length-1];
    const sameBar = last && last.time === incoming.time;
    if (sameBar) arr[arr.length-1] = incoming; else { arr.push(incoming); per[sym].lastWsCandleTs = incoming.time; }
    st.candles = clampStore(arr);

    // Only log if active to keep output readable
    if (sym === active){
      const ts = new Date(incoming.time).toLocaleTimeString();
      const delta = (last ? incoming.close - last.close : 0);
      pushLog(`${sameBar ? '‚ö°' : 'üü¢'} ${sym} [${ts}] O:${fmt(incoming.open)} H:${fmt(incoming.high)} L:${fmt(incoming.low)} C:${fmt(incoming.close)} (Œî ${fmt(delta)}) V:${fmt(incoming.volume,0)}`);
    }

    if (sym === active) { drawChart(); updateIndicators(sym); }
    drawSpark(sym);
    evaluateBuyAlert(sym);
  };
}

btnPause.onclick = ()=>{ livePaused = true; liveEl.textContent = 'Live: paused'; };
btnResume.onclick = ()=>{ livePaused = false; liveEl.textContent = 'Live: connected'; };
btnJumpNow.onclick = ()=> drawChart(true);

/** ==============================
 *  Indicators (same math across pairs)
 *  ============================== */
function SMA(p, arr){ if(arr.length<p) return null; let s=0; for(let i=arr.length-p;i<arr.length;i++) s+=arr[i].close; return s/p; }
function EMA(p, arr){ if(arr.length<p) return null; const k=2/(p+1); let ema=0,sum=0; for(let i=0;i<p;i++) sum+=arr[i].close; ema=sum/p; for(let i=p;i<arr.length;i++) ema=arr[i].close*k+ema*(1-k); return ema; }
function EMAArray(p,arr){ if(arr.length<p) return null; const k=2/(p+1); const out=[]; let sum=0; for(let i=0;i<p;i++) sum+=arr[i].close; let ema=sum/p; out.push(ema); for(let i=p;i<arr.length;i++){ ema=arr[i].close*k+ema*(1-k); out.push(ema);} return out; }
function EMAFromArray(p,series){ if(!series||series.length<p) return null; const k=2/(p+1); const out=[]; let sum=0; for(let i=0;i<p;i++) sum+=series[i]; let ema=sum/p; out.push(ema); for(let i=p;i<series.length;i++){ ema=series[i]*k+ema*(1-k); out.push(ema);} return out; }
function MACD(arr){ const e12=EMAArray(12,arr), e26=EMAArray(26,arr); if(!e12||!e26) return [null,null,null]; const n=Math.min(e12.length,e26.length); const macdLine=[]; for(let i=0;i<n;i++) macdLine.push(e12[e12.length-n+i]-e26[e26.length-n+i]); const signal=EMAFromArray(9,macdLine); if(!signal) return [null,null,null]; const hist=macdLine[macdLine.length-1]-signal[signal.length-1]; return [macdLine[macdLine.length-1], signal[signal.length-1], hist]; }
function RSI(p,arr){ if(arr.length<p+1) return null; let gains=0,losses=0; for(let i=arr.length-p;i<arr.length;i++){ const d=arr[i].close-arr[i-1].close; if(d>=0) gains+=d; else losses-=d; } const ag=gains/p, al=losses/p; if(al===0) return 100; const rs=ag/al; return 100-100/(1+rs); }
function Bollinger(p,arr){ if(arr.length<p) return [null,null,null]; const slice=arr.slice(-p); const mean=slice.reduce((a,c)=>a+c.close,0)/p; const variance=slice.reduce((a,c)=>a+(c.close-mean)**2,0)/p; const sd=Math.sqrt(variance); return [mean, mean+2*sd, mean-2*sd]; }
function ATR(p,arr){ if(arr.length<p+1) return null; const trs=[]; for(let i=1;i<arr.length;i++){ const h=arr[i].high,l=arr[i].low,pc=arr[i-1].close; trs.push(Math.max(h-l, Math.abs(h-pc), Math.abs(l-pc))); } const last=trs.slice(-p); return last.reduce((a,b)=>a+b,0)/p; }
function Donchian(p,arr){ if(arr.length<p) return [null,null]; const s=arr.slice(-p); return [Math.max(...s.map(x=>x.high)), Math.min(...s.map(x=>x.low))]; }
function VWAP(arr){ let tpv=0,vol=0; for(const k of arr){ const tp=(k.high+k.low+k.close)/3; tpv+=tp*k.volume; vol+=k.volume; } return vol? (tpv/vol):null; }
function OBV(arr){ if(arr.length<2) return 0; let obv=0; for(let i=1;i<arr.length;i++){ if(arr[i].close>arr[i-1].close) obv+=arr[i].volume; else if(arr[i].close<arr[i-1].close) obv-=arr[i].volume; } return obv; }
function Pivots(c){ if(!c) return [null,null,null]; const p=(c.high+c.low+c.close)/3; const s1=(2*p)-c.high; const r1=(2*p)-c.low; return [p,s1,r1]; }
function ParabolicSAR(arr, step=0.02, max=0.2){ if(arr.length<2) return null; let isUp=true, sar=arr[arr.length-2].low, ep=arr[arr.length-2].high, af=step; for(let i=arr.length-2;i<arr.length;i++){ if(isUp){ sar+=af*(ep-sar); if(arr[i].low<sar){ isUp=false; sar=ep; ep=arr[i].low; af=step; } else if(arr[i].high>ep){ ep=arr[i].high; af=Math.min(af+step,max); } } else { sar+=af*(ep-sar); if(arr[i].high>sar){ isUp=true; sar=ep; ep=arr[i].high; af=step; } else if(arr[i].low<ep){ ep=arr[i].low; af=Math.min(af+step,max); } } } return sar; }
function ADX(p,arr){ if(arr.length<p+1) return null; const plusDM=[],minusDM=[],trs=[]; for(let i=1;i<arr.length;i++){ const up=arr[i].high-arr[i-1].high; const dn=arr[i-1].low-arr[i].low; plusDM.push(up>dn&&up>0?up:0); minusDM.push(dn>up&&dn>0?dn:0); trs.push(Math.max(arr[i].high-arr[i].low, Math.abs(arr[i].high-arr[i-1].close), Math.abs(arr[i].low-arr[i-1].close))); } const avgTR=trs.slice(-p).reduce((a,b)=>a+b,0)/p; const avgPlus=plusDM.slice(-p).reduce((a,b)=>a+b,0)/p; const avgMinus=minusDM.slice(-p).reduce((a,b)=>a+b,0)/p; const plusDI=100*(avgPlus/avgTR), minusDI=100*(avgMinus/avgTR); const dx=100*Math.abs(plusDI-minusDI)/(plusDI+minusDI); return dx; }
let stochBufMap = new Map();
function Stochastic(p,arr,sym){ if(arr.length<p) return [null,null]; const s=arr.slice(-p); const hi=Math.max(...s.map(x=>x.high)); const lo=Math.min(...s.map(x=>x.low)); const close=arr[arr.length-1].close; const k=(hi===lo)?50:((close-lo)/(hi-lo))*100; let buf=stochBufMap.get(sym)||[]; buf.push(k); if(buf.length>3) buf.shift(); stochBufMap.set(sym,buf); const d=buf.length===3?(buf[0]+buf[1]+buf[2])/3:null; return [k,d]; }

/** ==============================
 *  Indicator Panel Update (active symbol)
 *  ============================== */
function updateIndicators(sym=active){
  const arr = per[sym].candles; const n=arr.length; if(n<30){ panel.textContent='‚è≥ Waiting for more candles‚Ä¶'; return; }
  const view = arr.slice(-150);
  const sma14=SMA(14,view); const ema14=EMA(14,view);
  const [macd,signal,hist]=MACD(view);
  const rsi14=RSI(14,view);
  const [bbMid,bbU,bbL]=Bollinger(20,view);
  const atr14=ATR(14,view);
  const [dcH,dcL]=Donchian(20,view);
  const vwap=VWAP(view);
  const obv=OBV(view);
  const [pivot,s1,r1]=Pivots(view[view.length-1]);
  const psar=ParabolicSAR(view);
  const adx14=ADX(14,view);
  const [stK,stD]=Stochastic(14,view,sym);
  const emaSignal=(ema14!=null && sma14!=null)? (ema14>sma14? 'üü¢ Bullish EMA> SMA': (ema14<sma14?'üî¥ Bearish EMA< SMA':'„Ä∞Ô∏è Flat')):'‚è≥';
  panel.innerHTML = `
    <h3>üîπ Trend</h3>
    ‚Ä¢ SMA14: ${fmt(sma14)}<br>
    ‚Ä¢ EMA14: ${fmt(ema14)}<br>
    ‚Ä¢ EMA vs SMA: ${emaSignal}<br>
    ‚Ä¢ MACD: ${fmt(macd,4)} / Signal: ${fmt(signal,4)} / Hist: <span class="${(hist||0)>=0?'green':'red'}">${fmt(hist,4)}</span><br>
    ‚Ä¢ Parabolic SAR: ${fmt(psar)}<br>
    ‚Ä¢ ADX(14): ${fmt(adx14)}
    <h3>üî∏ Momentum</h3>
    ‚Ä¢ RSI14: <span class="${(rsi14||0)>=50?'green':'red'}">${fmt(rsi14)}</span><br>
    ‚Ä¢ Stoch %K: ${fmt(stK)} ‚Äî %D: ${fmt(stD)}
    <h3>üå™Ô∏è Volatility</h3>
    ‚Ä¢ BB Mid: ${fmt(bbMid)} | Upper: ${fmt(bbU)} | Lower: ${fmt(bbL)}<br>
    ‚Ä¢ ATR14: ${fmt(atr14)}<br>
    ‚Ä¢ Donchian H/L(20): ${fmt(dcH)} / ${fmt(dcL)}
    <h3>üì¶ Volume</h3>
    ‚Ä¢ VWAP: ${fmt(vwap)}<br>
    ‚Ä¢ OBV: ${fmt(obv,0)}
    <h3>üîç Price Pivots</h3>
    ‚Ä¢ Pivot: ${fmt(pivot)} | S1: ${fmt(s1)} | R1: ${fmt(r1)}
  `;
}

/** ==============================
 *  BUY Alert Logic (uses ALL indicators cohesively)
 *  ============================== */
function evaluateBuyAlert(sym){
  const arr = per[sym].candles; if (arr.length < 30) return; // need data
  const view = arr.slice(-150);
  const last = view[view.length-1];
  const sma14=SMA(14,view); const ema14=EMA(14,view);
  const [macd,signal,hist]=MACD(view);
  const rsi14=RSI(14,view);
  const [bbMid]=Bollinger(20,view);
  const atr14=ATR(14,view);
  const [dcH,dcL]=Donchian(20,view);
  const vwap=VWAP(view);
  const obv=OBV(view);
  const [pivot]=Pivots(last);
  const psar=ParabolicSAR(view);
  const adx14=ADX(14,view);
  const [stK,stD]=Stochastic(14,view,sym);

  // Cohesive BUY rule requiring confirmations across indicators
  const trendUp = (ema14!=null&&sma14!=null) && ema14>sma14;
  const macdBull = macd!=null && signal!=null && macd>signal && (hist||0)>0;
  const rsiBull = (rsi14||0) >= 55;
  const priceAboveBBmid = bbMid!=null && last.close > bbMid;
  const psarBull = psar!=null && last.close > psar;
  const adxOk = (adx14||0) >= 18; // trend strength
  const stochUp = stK!=null && stD!=null && stK > stD && stK < 85;
  const aboveVWAP = vwap!=null && last.close > vwap;
  const abovePivot = pivot!=null && last.close > pivot;
  const donchianNearHigh = (dcH!=null) && (last.close > (dcH + dcL)/2);
  const obvNotFalling = (obv||0) >= 0; // simple non-negative since we compute relative

  const ok = trendUp && macdBull && rsiBull && priceAboveBBmid && psarBull && adxOk && stochUp && aboveVWAP && abovePivot && donchianNearHigh && obvNotFalling;

  const badge = document.getElementById(`bd_${sym}`);
  if (ok){
    badge.textContent = 'BUY'; badge.className = 'badg buy';
  } else {
    badge.textContent = '‚Äî'; badge.className = 'badg';
  }

  // Trigger native popup only ONCE per candle when conditions flip true
  const lastTs = per[sym].lastAlertTs || 0;
  const candleTs = last.time; // ms
  if (ok && candleTs !== lastTs){
    per[sym].lastAlertTs = candleTs;
    const msg = `${sym} BUY @ ${fmt(last.close)}  | EMA>SMA, MACD+, RSI ${fmt(rsi14)} | ADX ${fmt(adx14)} | VWAP ${fmt(vwap)} | BBmid ${fmt(bbMid)}`;
    pushLog(`üîî ${msg}`);
    notify(`BUY Alert ‚Äî ${sym}`, msg);
  }
}

/** ==============================
 *  Canvas Chart (active symbol)
 *  ============================== */
const canvas = document.getElementById('chart');
const ctx = canvas.getContext('2d');
function resizeCanvas(){ const dpr=window.devicePixelRatio||1; const rect=canvas.getBoundingClientRect(); canvas.width=rect.width*dpr; canvas.height=rect.height*dpr; ctx.setTransform(dpr,0,0,dpr,0,0); }
window.addEventListener('resize', ()=>{ resizeCanvas(); drawChart(); });
resizeCanvas();

function drawChart(scrollToEnd=false){
  const arr = per[active].candles; if (!arr.length) return; visNEl.textContent = VISIBLE;
  const w=canvas.clientWidth, h=canvas.clientHeight; ctx.clearRect(0,0,w,h);
  // grid
  ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = 1; for(let i=0;i<8;i++){ const y=(h/8)*i; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
  const view = arr.slice(-VISIBLE); const maxP=Math.max(...view.map(c=>c.high)); const minP=Math.min(...view.map(c=>c.low)); const cw=w/view.length;
  for(let i=0;i<view.length;i++){
    const c=view[i]; const x=i*cw; const yOpen=(1-(c.open-minP)/(maxP-minP))*h; const yClose=(1-(c.close-minP)/(maxP-minP))*h; const yHigh=(1-(c.high-minP)/(maxP-minP))*h; const yLow=(1-(c.low-minP)/(maxP-minP))*h;
    ctx.strokeStyle = (c.close>=c.open)? '#0f0' : '#ff4d4d'; ctx.beginPath(); ctx.moveTo(x+cw/2,yHigh); ctx.lineTo(x+cw/2,yLow); ctx.stroke();
    ctx.fillStyle = (c.close>=c.open)? '#0f0' : '#ff4d4d'; const bodyY=Math.min(yOpen,yClose); const bodyH=Math.max(2, Math.abs(yClose-yOpen)); ctx.fillRect(x+1, bodyY, Math.max(1,cw-2), bodyH);
  }
  const last = view[view.length-1]; ctx.fillStyle = '#00ffff'; ctx.fillText(`${active}  C: ${fmt(last.close)}`, 8, 14);
}

/** ==============================
 *  Sparkline mini charts per tile
 *  ============================== */
function drawSpark(sym){
  const arr = per[sym].candles; const el = document.getElementById(`sp_${sym}`); if(!el||arr.length<20) return; const ctx2 = el.getContext('2d');
  const dpr=window.devicePixelRatio||1; const rect=el.getBoundingClientRect(); el.width=rect.width*dpr; el.height=rect.height*dpr; ctx2.setTransform(dpr,0,0,dpr,0,0);
  ctx2.clearRect(0,0,el.clientWidth, el.clientHeight);
  const N=Math.min(120, arr.length); const v=arr.slice(-N); const w=el.clientWidth, h=el.clientHeight; const maxP=Math.max(...v.map(c=>c.high)); const minP=Math.min(...v.map(c=>c.low)); const dx=w/(v.length-1);
  ctx2.beginPath(); for(let i=0;i<v.length;i++){ const x=i*dx; const y=(1-(v[i].close-minP)/(maxP-minP))*h; if(i===0) ctx2.moveTo(x,y); else ctx2.lineTo(x,y);} ctx2.strokeStyle='#0f0'; ctx2.lineWidth=1.5; ctx2.stroke();
}

/** ==============================
 *  Kickoff
 *  ============================== */
(async function main(){
  await ensureNotify();
  await preloadAll();
  startCombinedWS();
  setInterval(()=> updateIndicators(active), 1000);
})();
</script>
</body>
</html>
